name: Auto-merge Kimi PRs

on:
  check_suite:
    types: [completed]
  pull_request_review:
    types: [submitted]

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Check if PR should be auto-merged
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let prNumber;
            
            // Get PR number based on event type
            if (context.eventName === 'check_suite') {
              const checkSuite = context.payload.check_suite;
              
              // Only proceed if all checks passed
              if (checkSuite.conclusion !== 'success') {
                console.log('Check suite did not succeed, skipping auto-merge');
                return;
              }
              
              // Find PR for this check suite
              const pulls = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${checkSuite.head_branch}`,
                state: 'open'
              });
              
              if (pulls.data.length === 0) {
                console.log('No open PR found for this branch');
                return;
              }
              
              prNumber = pulls.data[0].number;
            } else if (context.eventName === 'pull_request_review') {
              prNumber = context.payload.pull_request.number;
            } else {
              console.log('Unknown event type');
              return;
            }
            
            console.log(`Checking PR #${prNumber} for auto-merge eligibility`);
            
            // Get PR details
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            // Check if PR is from Kimi (branch starts with kimi/)
            if (!pr.data.head.ref.startsWith('kimi/')) {
              console.log('PR is not from Kimi, skipping auto-merge');
              return;
            }
            
            console.log(`PR #${prNumber} is from Kimi agent (branch: ${pr.data.head.ref})`);
            
            // Check if PR is mergeable
            if (pr.data.mergeable_state !== 'clean' && pr.data.mergeable_state !== 'unstable') {
              console.log(`PR is not in a mergeable state: ${pr.data.mergeable_state}`);
              return;
            }
            
            // Check all status checks
            const checks = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.data.head.sha,
              per_page: 100
            });
            
            const failedChecks = checks.data.check_runs.filter(
              check => check.conclusion !== 'success' && 
                       check.conclusion !== 'skipped' &&
                       check.conclusion !== 'neutral'
            );
            
            if (failedChecks.length > 0) {
              console.log(`${failedChecks.length} checks have not passed yet`);
              return;
            }
            
            console.log('All checks passed!');
            
            // Check for approvals
            const reviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const latestReviews = {};
            for (const review of reviews.data) {
              latestReviews[review.user.login] = review.state;
            }
            
            const approvals = Object.values(latestReviews).filter(state => state === 'APPROVED');
            const changesRequested = Object.values(latestReviews).filter(state => state === 'CHANGES_REQUESTED');
            
            // Require at least one approval and no change requests
            if (approvals.length === 0) {
              console.log('No approvals yet, waiting for review');
              
              // Add a comment requesting review
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: '‚úÖ All CI checks passed! This PR is ready for review and will be auto-merged once approved.'
              });
              
              return;
            }
            
            if (changesRequested.length > 0) {
              console.log('Changes requested, cannot auto-merge');
              return;
            }
            
            console.log(`PR has ${approvals.length} approval(s), proceeding with auto-merge`);
            
            // Merge the PR
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash',
                commit_title: `${pr.data.title} (#${prNumber})`,
                commit_message: `Automatically merged by Kimi GitHub Agent\n\n${pr.data.body || ''}`
              });
              
              console.log(`‚úÖ Successfully merged PR #${prNumber}`);
              
              // Delete the branch
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${pr.data.head.ref}`
                });
                console.log(`üóëÔ∏è  Deleted branch ${pr.data.head.ref}`);
              } catch (error) {
                console.log(`Could not delete branch: ${error.message}`);
              }
              
            } catch (error) {
              console.error(`‚ùå Failed to merge PR: ${error.message}`);
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `‚ö†Ô∏è Auto-merge failed: ${error.message}\n\nPlease merge manually.`
              });
            }
